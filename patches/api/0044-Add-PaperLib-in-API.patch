From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: DoctaEnkoda <bierquejason@gmail.com>
Date: Sat, 10 Jul 2021 04:06:05 +0200
Subject: [PATCH] Add PaperLib in API


diff --git a/src/main/java/io/papermc/lib/PaperLib.java b/src/main/java/io/papermc/lib/PaperLib.java
new file mode 100644
index 0000000000000000000000000000000000000000..87f9a42abd624f0d4cde96fdceda1718fc459147
--- /dev/null
+++ b/src/main/java/io/papermc/lib/PaperLib.java
@@ -0,0 +1,308 @@
+package io.papermc.lib;
+
+import io.papermc.lib.environments.CraftBukkitEnvironment;
+import io.papermc.lib.environments.Environment;
+import io.papermc.lib.environments.PaperEnvironment;
+import io.papermc.lib.environments.SpigotEnvironment;
+import io.papermc.lib.features.blockstatesnapshot.BlockStateSnapshotResult;
+import org.bukkit.Chunk;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.block.Block;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
+import org.bukkit.plugin.Plugin;
+
+import javax.annotation.Nonnull;
+import java.util.concurrent.CompletableFuture;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+/**
+ * Utility methods that assist plugin developers accessing Paper features.
+ * Bridges backwards compatability with Spigot and CraftBukkit so your plugin
+ * will still work on those platforms, and fall back to less performant methods.
+ */
+@SuppressWarnings("WeakerAccess")
+public class PaperLib {
+    private PaperLib() {
+        // Hide public constructor
+    }
+
+    private static Environment ENVIRONMENT = initialize();
+
+    private static Environment initialize() {
+        return new PaperEnvironment(); // Purpur-SinonMC use Purpuir use Tuinity use Paper
+    }
+
+    /**
+     * Gets a reference to the current environment. All of the static util methods in this class points to this
+     * environment.
+     *
+     * @return The Environment
+     */
+    @Nonnull
+    public static Environment getEnvironment() {
+        return ENVIRONMENT;
+    }
+
+    /**
+     * If you have need to inject a custom Environment, such as running on your own fork, or unit tests, do it here.
+     * @param environment Custom Environment
+     */
+    public static void setCustomEnvironment(@Nonnull Environment environment) {
+        ENVIRONMENT = environment;
+    }
+
+    /**
+     * Teleports an Entity to the target location, loading the chunk asynchronously first if needed.
+     * @param entity The Entity to teleport
+     * @param location The Location to Teleport to
+     * @return Future that completes with the result of the teleport
+     */
+    @Nonnull
+    public static CompletableFuture<Boolean> teleportAsync(@Nonnull Entity entity, @Nonnull Location location) {
+        return ENVIRONMENT.teleport(entity, location, TeleportCause.PLUGIN);
+    }
+
+    /**
+     * Teleports an Entity to the target location, loading the chunk asynchronously first if needed.
+     * @param entity The Entity to teleport
+     * @param location The Location to Teleport to
+     * @param cause The cause for the teleportation
+     * @return Future that completes with the result of the teleport
+     */
+    @Nonnull
+    public static CompletableFuture<Boolean> teleportAsync(@Nonnull Entity entity, @Nonnull Location location, TeleportCause cause) {
+        return ENVIRONMENT.teleport(entity, location, cause);
+    }
+
+    /**
+     * Gets the chunk at the target location, loading it asynchronously if needed.
+     * @param loc Location to get chunk for
+     * @return Future that completes with the chunk
+     */
+    @Nonnull
+    public static CompletableFuture<Chunk> getChunkAtAsync(@Nonnull Location loc) {
+        return getChunkAtAsync(loc.getWorld(), loc.getBlockX() >> 4, loc.getBlockZ() >> 4, true);
+    }
+
+    /**
+     * Gets the chunk at the target location, loading it asynchronously if needed.
+     * @param loc Location to get chunk for
+     * @param gen Should the chunk generate or not. Only respected on some MC versions, 1.13 for CB, 1.12 for Paper
+     * @return Future that completes with the chunk, or null if the chunk did not exists and generation was not requested.
+     */
+    @Nonnull
+    public static CompletableFuture<Chunk> getChunkAtAsync(@Nonnull Location loc, boolean gen) {
+        return getChunkAtAsync(loc.getWorld(), loc.getBlockX() >> 4, loc.getBlockZ() >> 4, gen);
+    }
+
+    /**
+     * Gets the chunk at the target location, loading it asynchronously if needed.
+     * @param world World to load chunk for
+     * @param x X coordinate of the chunk to load
+     * @param z Z coordinate of the chunk to load
+     * @return Future that completes with the chunk
+     */
+    @Nonnull
+    public static CompletableFuture<Chunk> getChunkAtAsync(@Nonnull World world, int x, int z) {
+        return getChunkAtAsync(world, x, z, true);
+    }
+
+    /**
+     * Gets the chunk at the target location, loading it asynchronously if needed.
+     * @param world World to load chunk for
+     * @param x X coordinate of the chunk to load
+     * @param z Z coordinate of the chunk to load
+     * @param gen Should the chunk generate or not. Only respected on some MC versions, 1.13 for CB, 1.12 for Paper
+     * @return Future that completes with the chunk, or null if the chunk did not exists and generation was not requested.
+     */
+    @Nonnull
+    public static CompletableFuture<Chunk> getChunkAtAsync(@Nonnull World world, int x, int z, boolean gen) {
+        return ENVIRONMENT.getChunkAtAsync(world, x, z, gen, false);
+    }
+
+    /**
+     * Gets the chunk at the target location, loading it asynchronously if needed.
+     * @param world World to load chunk for
+     * @param x X coordinate of the chunk to load
+     * @param z Z coordinate of the chunk to load
+     * @param gen Should the chunk generate or not. Only respected on some MC versions, 1.13 for CB, 1.12 for Paper
+     * @return Future that completes with the chunk, or null if the chunk did not exists and generation was not requested.
+     */
+    @Nonnull
+    public static CompletableFuture<Chunk> getChunkAtAsync(@Nonnull World world, int x, int z, boolean gen, boolean isUrgent) {
+        return ENVIRONMENT.getChunkAtAsync(world, x, z, gen, isUrgent);
+    }
+
+    /**
+     * Gets the chunk at the target location, loading it asynchronously if needed, with highest priority if supported
+     * @param world World to load chunk for
+     * @param x X coordinate of the chunk to load
+     * @param z Z coordinate of the chunk to load
+     * @param gen Should the chunk generate or not. Only respected on some MC versions, 1.13 for CB, 1.12 for Paper
+     * @return Future that completes with the chunk, or null if the chunk did not exists and generation was not requested.
+     */
+    @Nonnull
+    public static CompletableFuture<Chunk> getChunkAtAsyncUrgently(@Nonnull World world, int x, int z, boolean gen) {
+        return ENVIRONMENT.getChunkAtAsync(world, x, z, gen, true);
+    }
+
+    /**
+     * Checks if the chunk has been generated or not. Only works on Paper 1.12+ or any 1.13.1+ version
+     * @param loc Location to check if the chunk is generated
+     * @return If the chunk is generated or not
+     */
+    public static boolean isChunkGenerated(@Nonnull Location loc) {
+        return isChunkGenerated(loc.getWorld(), loc.getBlockX() >> 4, loc.getBlockZ() >> 4);
+    }
+
+    /**
+     * Checks if the chunk has been generated or not. Only works on Paper 1.12+ or any 1.13.1+ version
+     * @param world World to check for
+     * @param x X coordinate of the chunk to check
+     * @param z Z coordinate of the chunk to check
+     * @return If the chunk is generated or not
+     */
+    public static boolean isChunkGenerated(@Nonnull World world, int x, int z) {
+        return ENVIRONMENT.isChunkGenerated(world, x, z);
+    }
+
+    /**
+     * Get's a BlockState, optionally not using a snapshot
+     * @param block The block to get a State of
+     * @param useSnapshot Whether or not to use a snapshot when supported
+     * @return The BlockState
+     */
+    @Nonnull
+    public static BlockStateSnapshotResult getBlockState(@Nonnull Block block, boolean useSnapshot) {
+        return ENVIRONMENT.getBlockState(block, useSnapshot);
+    }
+
+    /**
+     * Gets the location where the target player will spawn at their bed, asynchronously if needed
+     * @param player   The player whose bed spawn location to get.
+     * @param isUrgent Whether or not this should be performed with highest priority when supported
+     * @return Future that completes with the location of the bed spawn location, or null if the player
+     * has not slept in a bed or if the bed spawn is invalid.
+     */
+    public static CompletableFuture<Location> getBedSpawnLocationAsync(@Nonnull Player player, boolean isUrgent) {
+        return ENVIRONMENT.getBedSpawnLocationAsync(player, isUrgent);
+    }
+
+    /**
+     * Detects if the current MC version is at least the following version.
+     *
+     * Assumes 0 patch version.
+     *
+     * @param minor Min Minor Version
+     * @return Meets the version requested
+     */
+    public static boolean isVersion(int minor) {
+        return ENVIRONMENT.isVersion(minor);
+    }
+
+    /**
+     * Detects if the current MC version is at least the following version.
+     * @param minor Min Minor Version
+     * @param patch Min Patch Version
+     * @return Meets the version requested
+     */
+    public static boolean isVersion(int minor, int patch) {
+        return ENVIRONMENT.isVersion(minor, patch);
+    }
+
+    /**
+     * Gets the current Minecraft Minor version. IE: 1.13.1 returns 13
+     * @return The Minor Version
+     */
+    public static int getMinecraftVersion() {
+        return ENVIRONMENT.getMinecraftVersion();
+    }
+
+    /**
+     * Gets the current Minecraft Patch version. IE: 1.13.1 returns 1
+     * @return The Patch Version
+     */
+    public static int getMinecraftPatchVersion() {
+        return ENVIRONMENT.getMinecraftPatchVersion();
+    }
+
+    /**
+     * Gets the current Minecraft Pre-Release version if applicable, otherwise -1. IE: "1.14.3 Pre-Release 4" returns 4
+     * @return The Pre-Release Version if applicable, otherwise -1
+     */
+    public static int getMinecraftPreReleaseVersion() {
+        return ENVIRONMENT.getMinecraftPreReleaseVersion();
+    }
+
+    /**
+     * Check if the server has access to the Spigot API
+     * @return True for Spigot <em>and</em> Paper environments
+     */
+    public static boolean isSpigot() {
+        return ENVIRONMENT.isSpigot();
+    }
+
+    /**
+     * Check if the server has access to the Paper API
+     * @return True for Paper environments
+     */
+    public static boolean isPaper() {
+        return ENVIRONMENT.isPaper();
+    }
+
+    /**
+     * Can be called during plugin initialization to inform the server owner they should switch to Paper
+     *
+     * If you do not mind helping spread Paper, please call this in your plugin onEnable to help spread
+     * awareness about Paper, and encourage them that your plugin is better when used with Paper!
+     *
+     * This passes the default logLevel of Level.INFO
+     *
+     * @param plugin Your plugin object
+     * @see #suggestPaper(Plugin, Level) 
+     */
+    public static void suggestPaper(@Nonnull Plugin plugin) {
+        suggestPaper(plugin, Level.INFO);
+    }
+
+    /**
+     * Can be called during plugin initialization to inform the server owner they should switch to Paper
+     *
+     * If you do not mind helping spread Paper, please call this in your plugin onEnable to help spread
+     * awareness about Paper, and encourage them that your plugin is better when used with Paper!
+     *
+     * @param plugin Your plugin object
+     * @param logLevel The logLevel you want to choose
+     */
+    public static void suggestPaper(@Nonnull Plugin plugin, @Nonnull Level logLevel) {
+        if (isPaper()) {
+            return;
+        }
+        final String benefitsProperty = "paperlib.shown-benefits";
+        final String pluginName = plugin.getDescription().getName();
+        final Logger logger = plugin.getLogger();
+        logger.log(logLevel, "====================================================");
+        logger.log(logLevel, " " + pluginName + " works better if you use Paper ");
+        logger.log(logLevel, " as your server software. ");
+        if (System.getProperty(benefitsProperty) == null) {
+            System.setProperty(benefitsProperty, "1");
+            logger.log(logLevel, "  ");
+            logger.log(logLevel, " Paper offers significant performance improvements,");
+            logger.log(logLevel, " bug fixes, security enhancements and optional");
+            logger.log(logLevel, " features for server owners to enhance their server.");
+            logger.log(logLevel, "  ");
+            logger.log(logLevel, " Paper includes Timings v2, which is significantly");
+            logger.log(logLevel, " better at diagnosing lag problems over v1.");
+            logger.log(logLevel, "  ");
+            logger.log(logLevel, " All of your plugins should still work, and the");
+            logger.log(logLevel, " Paper community will gladly help you fix any issues.");
+            logger.log(logLevel, "  ");
+            logger.log(logLevel, " Join the Paper Community @ https://papermc.io");
+        }
+        logger.log(logLevel, "====================================================");
+    }
+}
diff --git a/src/main/java/io/papermc/lib/environments/CraftBukkitEnvironment.java b/src/main/java/io/papermc/lib/environments/CraftBukkitEnvironment.java
new file mode 100644
index 0000000000000000000000000000000000000000..5fe30a4db1d26f5fa0fd55cf0ab45e0ffd6664de
--- /dev/null
+++ b/src/main/java/io/papermc/lib/environments/CraftBukkitEnvironment.java
@@ -0,0 +1,9 @@
+package io.papermc.lib.environments;
+
+public class CraftBukkitEnvironment extends Environment {
+
+    @Override
+    public String getName() {
+        return "CraftBukkit";
+    }
+}
diff --git a/src/main/java/io/papermc/lib/environments/Environment.java b/src/main/java/io/papermc/lib/environments/Environment.java
new file mode 100644
index 0000000000000000000000000000000000000000..dc586f91c853da3c58f08827ace7bf368c712ab4
--- /dev/null
+++ b/src/main/java/io/papermc/lib/environments/Environment.java
@@ -0,0 +1,143 @@
+package io.papermc.lib.environments;
+
+import io.papermc.lib.features.asyncchunks.AsyncChunks;
+import io.papermc.lib.features.asyncchunks.AsyncChunksSync;
+import io.papermc.lib.features.asyncteleport.AsyncTeleport;
+import io.papermc.lib.features.asyncteleport.AsyncTeleportSync;
+import io.papermc.lib.features.bedspawnlocation.BedSpawnLocation;
+import io.papermc.lib.features.bedspawnlocation.BedSpawnLocationSync;
+import io.papermc.lib.features.blockstatesnapshot.BlockStateSnapshot;
+import io.papermc.lib.features.blockstatesnapshot.BlockStateSnapshotBeforeSnapshots;
+import io.papermc.lib.features.blockstatesnapshot.BlockStateSnapshotNoOption;
+import io.papermc.lib.features.blockstatesnapshot.BlockStateSnapshotResult;
+import io.papermc.lib.features.chunkisgenerated.ChunkIsGenerated;
+import io.papermc.lib.features.chunkisgenerated.ChunkIsGeneratedApiExists;
+import io.papermc.lib.features.chunkisgenerated.ChunkIsGeneratedUnknown;
+import org.bukkit.Bukkit;
+import org.bukkit.Chunk;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.block.Block;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.Player;
+import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
+
+import javax.annotation.Nonnull;
+import java.util.concurrent.CompletableFuture;
+import java.util.regex.MatchResult;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+@SuppressWarnings("WeakerAccess")
+public abstract class Environment {
+
+    private final int minecraftVersion;
+    private final int minecraftPatchVersion;
+    private int minecraftPreReleaseVersion;
+
+    protected AsyncChunks asyncChunksHandler = new AsyncChunksSync();
+    protected AsyncTeleport asyncTeleportHandler = new AsyncTeleportSync();
+    protected ChunkIsGenerated isGeneratedHandler = new ChunkIsGeneratedUnknown();
+    protected BlockStateSnapshot blockStateSnapshotHandler;
+    protected BedSpawnLocation bedSpawnLocationHandler = new BedSpawnLocationSync();
+
+    public Environment() {
+        Pattern versionPattern = Pattern.compile("\\(MC: (\\d)\\.(\\d+)\\.?(\\d+?)?(?: Pre-Release )?(\\d)?\\)");
+        Matcher matcher = versionPattern.matcher(Bukkit.getVersion());
+        int version = 0;
+        int patchVersion = 0;
+        int preReleaseVersion = 0;
+        if (matcher.find()) {
+            MatchResult matchResult = matcher.toMatchResult();
+            try {
+                version = Integer.parseInt(matchResult.group(2), 10);
+            } catch (Exception ignored) {
+            }
+            if (matchResult.groupCount() >= 3) {
+                try {
+                    patchVersion = Integer.parseInt(matchResult.group(3), 10);
+                } catch (Exception ignored) {
+                }
+            }
+            if (matchResult.groupCount() >= 4) {
+                try {
+                    preReleaseVersion = Integer.parseInt(matcher.group(4));
+                } catch (Exception ignored) {
+                }
+            }
+        }
+        this.minecraftVersion = version;
+        this.minecraftPatchVersion = patchVersion;
+        this.minecraftPreReleaseVersion = preReleaseVersion;
+
+        // Common to all environments
+        if (isVersion(13, 1)) {
+            isGeneratedHandler = new ChunkIsGeneratedApiExists();
+        } else {
+            // TODO: Reflection based?
+        }
+        if (!isVersion(12)) {
+            blockStateSnapshotHandler = new BlockStateSnapshotBeforeSnapshots();
+        } else {
+            blockStateSnapshotHandler = new BlockStateSnapshotNoOption();
+        }
+    }
+
+    public abstract String getName();
+
+    public CompletableFuture<Chunk> getChunkAtAsync(World world, int x, int z, boolean gen) {
+        return asyncChunksHandler.getChunkAtAsync(world, x, z, gen, false);
+    }
+
+    public CompletableFuture<Chunk> getChunkAtAsync(World world, int x, int z, boolean gen, boolean isUrgent) {
+        return asyncChunksHandler.getChunkAtAsync(world, x, z, gen, isUrgent);
+    }
+
+    public CompletableFuture<Chunk> getChunkAtAsyncUrgently(World world, int x, int z, boolean gen) {
+        return asyncChunksHandler.getChunkAtAsync(world, x, z, gen, true);
+    }
+
+    public CompletableFuture<Boolean> teleport(Entity entity, Location location, TeleportCause cause) {
+        return asyncTeleportHandler.teleportAsync(entity, location, cause);
+    }
+
+    public boolean isChunkGenerated(World world, int x, int z) {
+        return isGeneratedHandler.isChunkGenerated(world, x, z);
+    }
+
+    public BlockStateSnapshotResult getBlockState(Block block, boolean useSnapshot) {
+        return blockStateSnapshotHandler.getBlockState(block, useSnapshot);
+    }
+
+    public CompletableFuture<Location> getBedSpawnLocationAsync(Player player, boolean isUrgent) {
+        return bedSpawnLocationHandler.getBedSpawnLocationAsync(player, isUrgent);
+    }
+
+    public boolean isVersion(int minor) {
+        return isVersion(minor, 0);
+    }
+
+    public boolean isVersion(int minor, int patch) {
+        return minecraftVersion > minor || (minecraftVersion >= minor && minecraftPatchVersion >= patch);
+    }
+
+    public int getMinecraftVersion() {
+        return minecraftVersion;
+    }
+
+    public int getMinecraftPatchVersion() {
+        return minecraftPatchVersion;
+    }
+
+    public int getMinecraftPreReleaseVersion() {
+        return minecraftPreReleaseVersion;
+    }
+
+    public boolean isSpigot() {
+        return false;
+    }
+
+    public boolean isPaper() {
+        return false;
+    }
+}
diff --git a/src/main/java/io/papermc/lib/environments/PaperEnvironment.java b/src/main/java/io/papermc/lib/environments/PaperEnvironment.java
new file mode 100644
index 0000000000000000000000000000000000000000..04859a6635b028383aa61f37ed6ab53809b328c3
--- /dev/null
+++ b/src/main/java/io/papermc/lib/environments/PaperEnvironment.java
@@ -0,0 +1,53 @@
+package io.papermc.lib.environments;
+
+import io.papermc.lib.features.asyncchunks.AsyncChunksPaper_13;
+import io.papermc.lib.features.asyncchunks.AsyncChunksPaper_15;
+import io.papermc.lib.features.asyncchunks.AsyncChunksPaper_9_12;
+import io.papermc.lib.features.asyncteleport.AsyncTeleportPaper;
+import io.papermc.lib.features.asyncteleport.AsyncTeleportPaper_13;
+import io.papermc.lib.features.bedspawnlocation.BedSpawnLocationPaper;
+import io.papermc.lib.features.blockstatesnapshot.BlockStateSnapshotOptionalSnapshots;
+import io.papermc.lib.features.chunkisgenerated.ChunkIsGeneratedApiExists;
+import org.bukkit.Location;
+import org.bukkit.World;
+import org.bukkit.entity.HumanEntity;
+
+public class PaperEnvironment extends SpigotEnvironment {
+
+    public PaperEnvironment() {
+        super();
+
+        if (isVersion(13, 1)) {
+            asyncChunksHandler = new AsyncChunksPaper_13();
+            asyncTeleportHandler = new AsyncTeleportPaper_13();
+        } else if (isVersion(9) && !isVersion(13)) {
+            asyncChunksHandler = new AsyncChunksPaper_9_12();
+            asyncTeleportHandler = new AsyncTeleportPaper();
+        }
+        if (isVersion(12)) {
+            // Paper added this API in 1.12 with same signature spigot did in 1.13
+            isGeneratedHandler = new ChunkIsGeneratedApiExists();
+            blockStateSnapshotHandler = new BlockStateSnapshotOptionalSnapshots();
+        }
+        if (isVersion(15, 2)) {
+            try {
+                // Try for new Urgent API in 1.15.2+, Teleport will automatically benefit from this
+                World.class.getDeclaredMethod("getChunkAtAsyncUrgently", Location.class);
+                asyncChunksHandler = new AsyncChunksPaper_15();
+                HumanEntity.class.getDeclaredMethod("getPotentialBedLocation");
+                bedSpawnLocationHandler = new BedSpawnLocationPaper();
+            } catch (NoSuchMethodException ignored) {}
+        }
+    }
+
+    @Override
+    public String getName() {
+        return "Paper";
+    }
+
+    @Override
+    public boolean isPaper() {
+        return true;
+    }
+
+}
diff --git a/src/main/java/io/papermc/lib/environments/SpigotEnvironment.java b/src/main/java/io/papermc/lib/environments/SpigotEnvironment.java
new file mode 100644
index 0000000000000000000000000000000000000000..4e39a506c874585e12dd86dc2e49719358e2d3df
--- /dev/null
+++ b/src/main/java/io/papermc/lib/environments/SpigotEnvironment.java
@@ -0,0 +1,19 @@
+package io.papermc.lib.environments;
+
+public class SpigotEnvironment extends CraftBukkitEnvironment {
+
+    public SpigotEnvironment() {
+        super();
+    }
+
+    @Override
+    public String getName() {
+        return "Spigot";
+    }
+
+    @Override
+    public boolean isSpigot() {
+        return true;
+    }
+
+}
diff --git a/src/main/java/io/papermc/lib/features/asyncchunks/AsyncChunks.java b/src/main/java/io/papermc/lib/features/asyncchunks/AsyncChunks.java
new file mode 100644
index 0000000000000000000000000000000000000000..86a3f18c862b6350a492c41bc48f9b8713fb61f8
--- /dev/null
+++ b/src/main/java/io/papermc/lib/features/asyncchunks/AsyncChunks.java
@@ -0,0 +1,13 @@
+package io.papermc.lib.features.asyncchunks;
+
+import org.bukkit.Chunk;
+import org.bukkit.World;
+
+import java.util.concurrent.CompletableFuture;
+
+public interface AsyncChunks {
+    default CompletableFuture<Chunk> getChunkAtAsync(World world, int x, int z, boolean gen) {
+        return getChunkAtAsync(world, x, z, gen, false);
+    }
+    CompletableFuture<Chunk> getChunkAtAsync(World world, int x, int z, boolean gen, boolean isUrgent);
+}
diff --git a/src/main/java/io/papermc/lib/features/asyncchunks/AsyncChunksPaper_13.java b/src/main/java/io/papermc/lib/features/asyncchunks/AsyncChunksPaper_13.java
new file mode 100644
index 0000000000000000000000000000000000000000..0fda7d283fcfb2fb9aea889598ee3226b3c11100
--- /dev/null
+++ b/src/main/java/io/papermc/lib/features/asyncchunks/AsyncChunksPaper_13.java
@@ -0,0 +1,13 @@
+package io.papermc.lib.features.asyncchunks;
+
+import org.bukkit.Chunk;
+import org.bukkit.World;
+
+import java.util.concurrent.CompletableFuture;
+
+public class AsyncChunksPaper_13 implements AsyncChunks {
+    @Override
+    public CompletableFuture<Chunk> getChunkAtAsync(World world, int x, int z, boolean gen, boolean isUrgent) {
+        return world.getChunkAtAsync(x, z, gen);
+    }
+}
diff --git a/src/main/java/io/papermc/lib/features/asyncchunks/AsyncChunksPaper_15.java b/src/main/java/io/papermc/lib/features/asyncchunks/AsyncChunksPaper_15.java
new file mode 100644
index 0000000000000000000000000000000000000000..04275c12dbbda70e6fd85fc32cf108bf436c1032
--- /dev/null
+++ b/src/main/java/io/papermc/lib/features/asyncchunks/AsyncChunksPaper_15.java
@@ -0,0 +1,13 @@
+package io.papermc.lib.features.asyncchunks;
+
+import org.bukkit.Chunk;
+import org.bukkit.World;
+
+import java.util.concurrent.CompletableFuture;
+
+public class AsyncChunksPaper_15 implements AsyncChunks {
+    @Override
+    public CompletableFuture<Chunk> getChunkAtAsync(World world, int x, int z, boolean gen, boolean isUrgent) {
+        return world.getChunkAtAsync(x, z, gen, isUrgent);
+    }
+}
diff --git a/src/main/java/io/papermc/lib/features/asyncchunks/AsyncChunksPaper_9_12.java b/src/main/java/io/papermc/lib/features/asyncchunks/AsyncChunksPaper_9_12.java
new file mode 100644
index 0000000000000000000000000000000000000000..78263ad870d781bb872be299a1e88c899f7c272d
--- /dev/null
+++ b/src/main/java/io/papermc/lib/features/asyncchunks/AsyncChunksPaper_9_12.java
@@ -0,0 +1,24 @@
+package io.papermc.lib.features.asyncchunks;
+
+import io.papermc.lib.PaperLib;
+import org.bukkit.Chunk;
+import org.bukkit.World;
+
+import java.util.concurrent.CompletableFuture;
+
+/**
+ * Async Chunk Loading for Paper version 1.9 to 1.12
+ */
+public class AsyncChunksPaper_9_12 implements AsyncChunks {
+    @Override
+    public CompletableFuture<Chunk> getChunkAtAsync(World world, int x, int z, boolean gen, boolean isUrgent) {
+        CompletableFuture<Chunk> future = new CompletableFuture<>();
+        if (!gen && PaperLib.getMinecraftVersion() >= 12 && !world.isChunkGenerated(x, z)) {
+            future.complete(null);
+        } else {
+            World.ChunkLoadCallback chunkLoadCallback = future::complete;
+            world.getChunkAtAsync(x, z, chunkLoadCallback);
+        }
+        return future;
+    }
+}
diff --git a/src/main/java/io/papermc/lib/features/asyncchunks/AsyncChunksSync.java b/src/main/java/io/papermc/lib/features/asyncchunks/AsyncChunksSync.java
new file mode 100644
index 0000000000000000000000000000000000000000..5a8672bc79527728d35bcc389c23827e5e4364a1
--- /dev/null
+++ b/src/main/java/io/papermc/lib/features/asyncchunks/AsyncChunksSync.java
@@ -0,0 +1,19 @@
+package io.papermc.lib.features.asyncchunks;
+
+import io.papermc.lib.PaperLib;
+import org.bukkit.Chunk;
+import org.bukkit.World;
+
+import java.util.concurrent.CompletableFuture;
+
+public class AsyncChunksSync implements AsyncChunks {
+
+    @Override
+    public CompletableFuture<Chunk> getChunkAtAsync(World world, int x, int z, boolean gen, boolean isUrgent) {
+        if (!gen && !PaperLib.isChunkGenerated(world, x, z)) {
+            return CompletableFuture.completedFuture(null);
+        } else {
+            return CompletableFuture.completedFuture(world.getChunkAt(x, z));
+        }
+    }
+}
diff --git a/src/main/java/io/papermc/lib/features/asyncteleport/AsyncTeleport.java b/src/main/java/io/papermc/lib/features/asyncteleport/AsyncTeleport.java
new file mode 100644
index 0000000000000000000000000000000000000000..1ea7cf12de5e7676d3063b2994a43e10271120d3
--- /dev/null
+++ b/src/main/java/io/papermc/lib/features/asyncteleport/AsyncTeleport.java
@@ -0,0 +1,11 @@
+package io.papermc.lib.features.asyncteleport;
+
+import org.bukkit.Location;
+import org.bukkit.entity.Entity;
+import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
+
+import java.util.concurrent.CompletableFuture;
+
+public interface AsyncTeleport {
+    CompletableFuture<Boolean> teleportAsync(Entity entity, Location location, TeleportCause cause);
+}
diff --git a/src/main/java/io/papermc/lib/features/asyncteleport/AsyncTeleportPaper.java b/src/main/java/io/papermc/lib/features/asyncteleport/AsyncTeleportPaper.java
new file mode 100644
index 0000000000000000000000000000000000000000..b81f01873b71af11521868e225cbc2fe39c927aa
--- /dev/null
+++ b/src/main/java/io/papermc/lib/features/asyncteleport/AsyncTeleportPaper.java
@@ -0,0 +1,19 @@
+package io.papermc.lib.features.asyncteleport;
+
+import io.papermc.lib.PaperLib;
+import org.bukkit.Location;
+import org.bukkit.entity.Entity;
+import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
+
+import java.util.concurrent.CompletableFuture;
+
+public class AsyncTeleportPaper implements AsyncTeleport {
+
+    @Override
+    public CompletableFuture<Boolean> teleportAsync(Entity entity, Location location, TeleportCause cause) {
+        int x = location.getBlockX() >> 4;
+        int z = location.getBlockZ() >> 4;
+        return PaperLib.getChunkAtAsyncUrgently(location.getWorld(), x, z, true).thenApply(chunk -> entity.teleport(location, cause));
+    }
+
+}
diff --git a/src/main/java/io/papermc/lib/features/asyncteleport/AsyncTeleportPaper_13.java b/src/main/java/io/papermc/lib/features/asyncteleport/AsyncTeleportPaper_13.java
new file mode 100644
index 0000000000000000000000000000000000000000..bfe7a7be6a9dd27ae60ed09ee04b177caccf878d
--- /dev/null
+++ b/src/main/java/io/papermc/lib/features/asyncteleport/AsyncTeleportPaper_13.java
@@ -0,0 +1,16 @@
+package io.papermc.lib.features.asyncteleport;
+
+import org.bukkit.Location;
+import org.bukkit.entity.Entity;
+import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
+
+import java.util.concurrent.CompletableFuture;
+
+public class AsyncTeleportPaper_13 implements AsyncTeleport {
+
+    @Override
+    public CompletableFuture<Boolean> teleportAsync(Entity entity, Location location, TeleportCause cause) {
+        return entity.teleportAsync(location, cause);
+    }
+
+}
diff --git a/src/main/java/io/papermc/lib/features/asyncteleport/AsyncTeleportSync.java b/src/main/java/io/papermc/lib/features/asyncteleport/AsyncTeleportSync.java
new file mode 100644
index 0000000000000000000000000000000000000000..be59a2535de289904b232fa910442a3fb62d549c
--- /dev/null
+++ b/src/main/java/io/papermc/lib/features/asyncteleport/AsyncTeleportSync.java
@@ -0,0 +1,16 @@
+package io.papermc.lib.features.asyncteleport;
+
+import org.bukkit.Location;
+import org.bukkit.entity.Entity;
+import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
+
+import java.util.concurrent.CompletableFuture;
+
+public class AsyncTeleportSync implements AsyncTeleport {
+
+    @Override
+    public CompletableFuture<Boolean> teleportAsync(Entity entity, Location location, TeleportCause cause) {
+        return CompletableFuture.completedFuture(entity.teleport(location, cause));
+    }
+
+}
diff --git a/src/main/java/io/papermc/lib/features/bedspawnlocation/BedSpawnLocation.java b/src/main/java/io/papermc/lib/features/bedspawnlocation/BedSpawnLocation.java
new file mode 100644
index 0000000000000000000000000000000000000000..4dfbabff64c3e32ade61441681e94ee52836a393
--- /dev/null
+++ b/src/main/java/io/papermc/lib/features/bedspawnlocation/BedSpawnLocation.java
@@ -0,0 +1,10 @@
+package io.papermc.lib.features.bedspawnlocation;
+
+import org.bukkit.Location;
+import org.bukkit.entity.Player;
+
+import java.util.concurrent.CompletableFuture;
+
+public interface BedSpawnLocation {
+    CompletableFuture<Location> getBedSpawnLocationAsync(Player player, boolean isUrgent);
+}
diff --git a/src/main/java/io/papermc/lib/features/bedspawnlocation/BedSpawnLocationPaper.java b/src/main/java/io/papermc/lib/features/bedspawnlocation/BedSpawnLocationPaper.java
new file mode 100644
index 0000000000000000000000000000000000000000..bc884e976a3a4e0eae822b03585f3a73e0c0881f
--- /dev/null
+++ b/src/main/java/io/papermc/lib/features/bedspawnlocation/BedSpawnLocationPaper.java
@@ -0,0 +1,19 @@
+package io.papermc.lib.features.bedspawnlocation;
+
+import io.papermc.lib.PaperLib;
+import org.bukkit.Location;
+import org.bukkit.entity.Player;
+
+import java.util.concurrent.CompletableFuture;
+
+public class BedSpawnLocationPaper implements BedSpawnLocation {
+
+    @Override
+    public CompletableFuture<Location> getBedSpawnLocationAsync(Player player, boolean isUrgent) {
+        Location bedLocation = player.getPotentialBedLocation();
+        if (bedLocation == null || bedLocation.getWorld() == null) {
+            return CompletableFuture.completedFuture(null);
+        }
+        return PaperLib.getChunkAtAsync(bedLocation.getWorld(), bedLocation.getBlockX() >> 4, bedLocation.getBlockZ() >> 4, false, isUrgent).thenCompose(chunk -> CompletableFuture.completedFuture(player.getBedSpawnLocation()));
+    }
+}
diff --git a/src/main/java/io/papermc/lib/features/bedspawnlocation/BedSpawnLocationSync.java b/src/main/java/io/papermc/lib/features/bedspawnlocation/BedSpawnLocationSync.java
new file mode 100644
index 0000000000000000000000000000000000000000..cc10fea6ed6a5c61dc77f70b47ee9d8c535ddb92
--- /dev/null
+++ b/src/main/java/io/papermc/lib/features/bedspawnlocation/BedSpawnLocationSync.java
@@ -0,0 +1,14 @@
+package io.papermc.lib.features.bedspawnlocation;
+
+import org.bukkit.Location;
+import org.bukkit.entity.Player;
+
+import java.util.concurrent.CompletableFuture;
+
+public class BedSpawnLocationSync implements BedSpawnLocation {
+
+    @Override
+    public CompletableFuture<Location> getBedSpawnLocationAsync(Player player, boolean isUrgent) {
+        return CompletableFuture.completedFuture(player.getBedSpawnLocation());
+    }
+}
diff --git a/src/main/java/io/papermc/lib/features/blockstatesnapshot/BlockStateSnapshot.java b/src/main/java/io/papermc/lib/features/blockstatesnapshot/BlockStateSnapshot.java
new file mode 100644
index 0000000000000000000000000000000000000000..e26a2df56a57965ce49da554eaaa03c027d150d9
--- /dev/null
+++ b/src/main/java/io/papermc/lib/features/blockstatesnapshot/BlockStateSnapshot.java
@@ -0,0 +1,7 @@
+package io.papermc.lib.features.blockstatesnapshot;
+
+import org.bukkit.block.Block;
+
+public interface BlockStateSnapshot {
+    BlockStateSnapshotResult getBlockState(Block block, boolean useSnapshot);
+}
diff --git a/src/main/java/io/papermc/lib/features/blockstatesnapshot/BlockStateSnapshotBeforeSnapshots.java b/src/main/java/io/papermc/lib/features/blockstatesnapshot/BlockStateSnapshotBeforeSnapshots.java
new file mode 100644
index 0000000000000000000000000000000000000000..1d11a19a92b6ed8264371b4298c4fadd79f96f93
--- /dev/null
+++ b/src/main/java/io/papermc/lib/features/blockstatesnapshot/BlockStateSnapshotBeforeSnapshots.java
@@ -0,0 +1,14 @@
+package io.papermc.lib.features.blockstatesnapshot;
+
+import org.bukkit.block.Block;
+
+/**
+ * Block State Snapshots was added in 1.12, this will always be no snapshots
+ */
+public class BlockStateSnapshotBeforeSnapshots implements BlockStateSnapshot {
+
+    @Override
+    public BlockStateSnapshotResult getBlockState(Block block, boolean useSnapshot) {
+        return new BlockStateSnapshotResult(false, block.getState());
+    }
+}
diff --git a/src/main/java/io/papermc/lib/features/blockstatesnapshot/BlockStateSnapshotNoOption.java b/src/main/java/io/papermc/lib/features/blockstatesnapshot/BlockStateSnapshotNoOption.java
new file mode 100644
index 0000000000000000000000000000000000000000..af4566b3be1b44e5ed77b9b99ff98cc89660e957
--- /dev/null
+++ b/src/main/java/io/papermc/lib/features/blockstatesnapshot/BlockStateSnapshotNoOption.java
@@ -0,0 +1,10 @@
+package io.papermc.lib.features.blockstatesnapshot;
+
+import org.bukkit.block.Block;
+
+public class BlockStateSnapshotNoOption implements BlockStateSnapshot {
+    @Override
+    public BlockStateSnapshotResult getBlockState(Block block, boolean useSnapshot) {
+        return new BlockStateSnapshotResult(true, block.getState());
+    }
+}
diff --git a/src/main/java/io/papermc/lib/features/blockstatesnapshot/BlockStateSnapshotOptionalSnapshots.java b/src/main/java/io/papermc/lib/features/blockstatesnapshot/BlockStateSnapshotOptionalSnapshots.java
new file mode 100644
index 0000000000000000000000000000000000000000..d5c42c9b2258fc28b79aee721fdb7f17f7dfebf9
--- /dev/null
+++ b/src/main/java/io/papermc/lib/features/blockstatesnapshot/BlockStateSnapshotOptionalSnapshots.java
@@ -0,0 +1,10 @@
+package io.papermc.lib.features.blockstatesnapshot;
+
+import org.bukkit.block.Block;
+
+public class BlockStateSnapshotOptionalSnapshots implements BlockStateSnapshot {
+    @Override
+    public BlockStateSnapshotResult getBlockState(Block block, boolean useSnapshot) {
+        return new BlockStateSnapshotResult(useSnapshot, block.getState(useSnapshot));
+    }
+}
diff --git a/src/main/java/io/papermc/lib/features/blockstatesnapshot/BlockStateSnapshotResult.java b/src/main/java/io/papermc/lib/features/blockstatesnapshot/BlockStateSnapshotResult.java
new file mode 100644
index 0000000000000000000000000000000000000000..2659ec57855a3d185048bc768bd79c82a005eeae
--- /dev/null
+++ b/src/main/java/io/papermc/lib/features/blockstatesnapshot/BlockStateSnapshotResult.java
@@ -0,0 +1,21 @@
+package io.papermc.lib.features.blockstatesnapshot;
+
+import org.bukkit.block.BlockState;
+
+public class BlockStateSnapshotResult {
+    private final boolean isSnapshot;
+    private final BlockState state;
+
+    public BlockStateSnapshotResult(boolean isSnapshot, BlockState state) {
+        this.isSnapshot = isSnapshot;
+        this.state = state;
+    }
+
+    public boolean isSnapshot() {
+        return isSnapshot;
+    }
+
+    public BlockState getState() {
+        return state;
+    }
+}
diff --git a/src/main/java/io/papermc/lib/features/chunkisgenerated/ChunkIsGenerated.java b/src/main/java/io/papermc/lib/features/chunkisgenerated/ChunkIsGenerated.java
new file mode 100644
index 0000000000000000000000000000000000000000..5b3640aad984569d8239b505fb12e825eb5327a5
--- /dev/null
+++ b/src/main/java/io/papermc/lib/features/chunkisgenerated/ChunkIsGenerated.java
@@ -0,0 +1,7 @@
+package io.papermc.lib.features.chunkisgenerated;
+
+import org.bukkit.World;
+
+public interface ChunkIsGenerated {
+    boolean isChunkGenerated(World world, int x, int z);
+}
diff --git a/src/main/java/io/papermc/lib/features/chunkisgenerated/ChunkIsGeneratedApiExists.java b/src/main/java/io/papermc/lib/features/chunkisgenerated/ChunkIsGeneratedApiExists.java
new file mode 100644
index 0000000000000000000000000000000000000000..e4d067375a53e82050579ade29b129973d55ef98
--- /dev/null
+++ b/src/main/java/io/papermc/lib/features/chunkisgenerated/ChunkIsGeneratedApiExists.java
@@ -0,0 +1,10 @@
+package io.papermc.lib.features.chunkisgenerated;
+
+import org.bukkit.World;
+
+public class ChunkIsGeneratedApiExists implements ChunkIsGenerated {
+    @Override
+    public boolean isChunkGenerated(World world, int x, int z) {
+        return world.isChunkGenerated(x, z);
+    }
+}
diff --git a/src/main/java/io/papermc/lib/features/chunkisgenerated/ChunkIsGeneratedUnknown.java b/src/main/java/io/papermc/lib/features/chunkisgenerated/ChunkIsGeneratedUnknown.java
new file mode 100644
index 0000000000000000000000000000000000000000..209da8eda67e15486982eaa51926ca836f057cdf
--- /dev/null
+++ b/src/main/java/io/papermc/lib/features/chunkisgenerated/ChunkIsGeneratedUnknown.java
@@ -0,0 +1,10 @@
+package io.papermc.lib.features.chunkisgenerated;
+
+import org.bukkit.World;
+
+public class ChunkIsGeneratedUnknown implements ChunkIsGenerated {
+    @Override
+    public boolean isChunkGenerated(World world, int x, int z) {
+        return true;
+    }
+}
